# 함수 Part 2

## 범위(Scope)

- Scope:함수, if, for문 등에 모두 해당

- 1.  변수는 코드에서 선언이 되어야, 그 이하의 코드에서 접근 가능(선언하기 이전에는 접근 불가함) (전역변수는 예외)

- 2.  상위스코프(범위)에 선언된 변수와 상수에 접근가능하며, 하위스코프(범위)에는 접근할 수 없다.

- 3.  (동일한 스코프에서 이름이 중복될 수 없지만, 다른 스코프에서는 이름 중복이 가능)

- 4.  가장 인접한 스코프에 있는 변수와 상수에 먼저 접근 한다.

### 첫번째 예제

```
func greeting1() {

    print("Hello")

    var myName = "홍길동"
    print(myName)

    print(name)

    if true {
        print(myName)
        print(name)
    }
}


// print(myName)

// print(name)




greeting1()

// 원칙은 함수 실행 전에(함수 선언 전이 아닌) name이라는 변수를 선언하는 것이다.

// 실제 앱을 만들때는 name이라는 전역변수를 함수 실행 전에 먼저 선언해 줘야 한다.


var name = "잡스" // 전역변수 (메모리의 데이터 영역에 저장)

// 플레이그라운드 파일이기 때문에 에러가 발생 X. 실제 앱개발에서는 에러 발생


greeting1()

```

### 두번째 예제

```
 var realName = "iOS-Jay"

// 전역 변수로서 미리 선언되어 있었다면 당연히 실행됨

func doSomething() {

 var realName = "앨런"

    print(realName)

    // 코드는 순서대로 작동하기 때문에, 선언이 되어있어야 사용 가능: 조건문에서 배운 프로그래밍의 기본 원칙 첫번쨰 -> 순차

//    var realName = "앨런"

    print(realName)
}


doSomething()

```

### 세번째 예제

```
func sayGreeting1() {

    print("Hello")


    func sayGreeting2() {

        print("Hey")

        if true {

            print("")
        }
    }

    sayGreeting2()  // 내부이니 접근 가능

}


// sayGreeting1()

// sayGreeting2() -> sayGreeting1() 내부에 있는 함수이기 때문에 밖에서 접근이 불가능하다.



```

# 제어전송문 정리

## 1) break

- (1) switch문 (2)반복문(for / while 등) 에서 사용

```

var a = 3

switch a {
case 1:
    break      // 실행하는 문장이 없을때, 반드시 입력 (약속)
case 2:
    print(a)
case 3:
    print("3입니다.")
case 4:
    print("안녕하세요")
default:
    break
}



// 가장 인접한 반복문을 아예 중지 ⭐️

for index in 1...10 {

    if index == 3 {
        break
    }

    print(index)
}


```

## 2) fallthrough

- switch문에서 사용

```
switch a {
case 1:
    break      // 실행하는 문장이 없을때, 반드시 입력 (약속)
case 2:
    print(a)
case 3:
    print("3입니다.")
    fallthrough
case 4:
    print("안녕하세요.")
default:
    break
}


// 3입니다.

// 안녕하세요.



```

## 3) continue

- 반복문에서 사용(for/ while 등)

```
for index in 1...10 {

    if index % 2 != 0 {
        continue
    }

    print(index)

    /* 간단하게 말해 건너뛰라는 뜻.

  continue는 반복문을 다음 싸이클로 보냄

  다음 싸이클에서 계속 지속(continue)하라는 의미

  1) 반복문의 첫번째 index는 1

  2) 1은 2로 나눴을 때 나머지가 1이므로 참

  3) 조건이 참이므로 continue를 만남

  4) continue를 만나므로 print(index)를 실행 시킬 수 없음

  5) 첫 문장을 실행시키지 않고 다음 사이클(index = 2)로 넘어감

  6) 2는 나머지가 0이므로 거짓, 따라서 continue를 실행시키지 않음

  7) 즉 if문을 실행시키지 않고 if문 다음의 print(index)를 실행

  8) 홀수 숫자는 continue를 만나고 짝수는 print 함수를 만남. 짝수가 출력됨



 */
}

```

## 4) return

- 함수에서 사용

```
func doSomething() {

    print("1")

    print("2")

    if true {

        return
    }

    // 리턴 타입이 없으므로 함수의 실행을 중지하고 함수를 벗어남

    print("3")

    print("4")

}


doSomething()

```

## inout 파라미터

- 함수를 통해, 변수를 직접 수정하고 싶은 경우는 어떻게 해야할까?

> #### **함수내의 파라미터는 기본적으로 값타입이고(복사되서 전달) 임시상수이기 때문에 변경 불가 원칙**

```
var num1 = 123     // 전역변수

var num2 = 456     // 전역변수


func swap(a: Int, b: Int) {

// 파라미터는 상수로 선언     let a = ..., let b = ...

//    var c = a     // 123

//    a = b         // a = 456

// a는 상수로 선언이 되있기 때문에 실행이 불가하다.

//    b = c         // b = 123

}


swap(a: num1, b: num2)

```

swap 함수라는 스택프레임을 만들었고,

밖에 있는 전역변수로 선언되어 있는 값들을

복사를 해서 내부에서 사용하게 된다.

그래서 원래의 값을 변경시킬 수 없다.

원래의 데이터를 복사했기 때문에.

파라미터는 기본적으로 값타입(복사되어 전달)

### 함수 내에서 변수를 직접 수정하도록 돕는 inout키워드 (참조로 전달)

- inout 키워드(선언시), & 사용(실행시)

> #### **참조로 전달한다는 뜻은 메모리의 주소를 전달한다는 개념이다.**

```

var num1 = 123

var num2 = 456

func swapNumbers(a: inout Int, b: inout Int) {

    var temp = a

    a = b   // 실질적으로 num1이 전달됨. num1 = b

    b = temp
}

swapNumbers(a: &num1, b: &num2)


print(num1)     // 456

print(num2)     // 123




```

- inout 키워드를 쓰면 그냥 변수를 전달하는구나, 상수로 선언하는 것이 아닌 밖에 있는 변수 그 자체를 전달한다고 알면 된다.

- 함수 실행시에는 앰퍼센트를 꼭 붙여야함(원본이 전달된다는 의미)

- 실행을 할 때는 &(엠퍼센트) 기호를 붙임. 주의하라는 의미(값이 복사된 것이 아닌 주소가 전달되었음을 알려주는 기호)

- 입출력 파라미터는 내부적으로 copy-in, copy-out 메모리 모델을 사용하지만, 실제 원본이 전달된다고 쉽게 생각하면 됨

- copy-in, copy-out값을 복사해서 함수 바디 내부로 전달하고,

- 함수가 종료될때, 아규먼트로 전달한 변수에 복사됨(함수 바디 내부에서 외부로 복사되어 전달)

### inout파라미터 사용시 주의점

1.  상수(let)나, 리터럴 전달하는 것 불가능

- (변하지 않는 값(let)이므로 불가, 직접적으로 123.... 이러한 데이터를 전달해서는 안됨( &123...불가능). 메모리 주소를 전달하는 것이기 때문에 값 자체를 전달하는 것은 안된다.)

2.  파라미터의 기본값 선언을 허용하지 않음

- (값을 바꿀 수 없는 것이니 당연히 선언 불가하다. a: Int = 5... 이런 행위로는 inout키워드 사용이 가능하지 않다.)

3.  가변파라미터(여러개의 파라미터)로 선언하는 것 불가능

## 가드문(Guard Statement)

- 불만족하는 조건을 사전에 걸러내는 조건문

> #### **if문의 단점 - 여러개의 조건이 있을때 코드의 가독성이 문제됨 ➞ guard문으로 단점 극복**

- Swift에서 만든 조건문. 다른 언어에서는 없는 개념

- if문을 만족하는 경우, 지속적인 들여쓰기로 인해 코드의 가속성이 안 좋아질 수 있음

- (실제 프로젝트에서는 코드를 알아보기 힘듬)

### guard문

1.  else문을 먼저 배치 - 먼저 조건을 판별하여 조기 종료(early exit)

2.  조건을 만족하는 경우 코드가 다음 줄로 넘어가서 계속 실행

3.  가드문에서 선언된 변수를 아래문장에서 사용 가능 (동일한 스코프로 취급): guard let 바인딩 관련

### 가드문의 이해

```
func checkNumbersOf1(password: String) -> Bool {

    if password.count >= 6 {

        // 로그인을 처리하는 코드 작성

        // 1

        // 2

        // 3

        // 4

        // 5

        return true

    } else {

        return false

    }

}




func checkNumbersOf2(password: String) -> Bool {

    // 감시하다

    guard password.count >= 6 else {

    // early exit:일찍 종료 시킴

        return false

    // 종료 조건 - 함수 내에서는 return / throw
    }

    // 로그인을 처리하는 코드 작성

    // 1

    // 2

    // 3

    // 4

    // 5

    return true
}


```

> 조건문과 다르게 else문이 먼저 나오는 조건문이라고 생각하면 된다.

### 가드문의 사용 예시

- 반드시 코드를 종료해야 하는 조기 종료의 조건이 필요하므로, 로컬스코프(함수/반복문) 내에서만 사용 가능

```
unc check(words: String) -> Bool {

    guard words.count >= 5 else {

        print("5글자 미만입니다.")

        return false                             // 종료 조건 - 함수 내에서는 return / throw
    }

    print("\(words.count)글자입니다.")

    return true
}



check(words: "안녕하세요")


```

## 함수의 리턴값 유무

- 함수의 정의

> 리턴값(타입)이 없는 함수

```
func sayHello() {

    print("안녕하세요.")

}




// sayHello() 결과값 존재 X(Void). CPU의 제어권만 존재


@discardableResult

// discardable: 버릴 수 있는
func sayHelloString() -> String {

    print("하이")

    return "안녕하세요"     // 결과적으로 출력은 "하이"만 함.

}

sayHelloString()    // 실제 프로젝트에서 경고창 표시: 결과값("안녕하세요".)를 왜 사용하지 않느냐?

```

- 경고창을 없애려면 변수에 담아서 사용하거나 출력(print)을 하거나 와일드 카드 패턴을 사용함.

- \_ = sayHelloString():"안녕하세요" 가 반환이 되는데, 이 값을 생략할 것이라고 말해주는 개념

- 과거 스위프트 버전 4 이하에서 사용하던 개념

- 스위프트 5.2부터 @discardableResult 사용

### 리턴 타입이 없는 함수(Void 타입) vs 리턴타입이 있는 함수의 차이 ⭐️

> #### **리턴 타입이 없는 함수 ➞ 결과는 Void 타입**

```
// 이렇게 사용하는 경우는 없음(결과값 없음)

// var hello: Void = sayhello1()

sayHello()         // 제어권

```

> #### **리턴 타입이 있는 함수 ➞ 결국 결과로 "값"이 있는 것 ➞ (일반적으로)사용**

- 함수 자체를 값으로 볼 수 있음

```
var hello = sayHelloString()       // 제어권 + 결과값

```

### 리턴값이 있는 함수에서 리턴값을 사용하지 않는다면

- 기존의 방식: (결과값을 사용하지 않을때) 지금까지 많이 사용해오던 패턴

```

_ = sayHelloString()

```

> 스위프트 5.2 부터: @discardableResult -> 어트리뷰트를 사용하도록함
