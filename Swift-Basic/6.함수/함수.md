# 함수 Part 1

## 함수(Function): "특정한 작업(기능)"을 수행하는 코드의 묶음에 식별할 수 있는특정한 이름을 부여하여 사용하는 것

> #### **함수(function)를 작성하는 방법(약속): 함수는 항상 2단계로 실행**

##### 1) 함수 정의문: 함수를 정의한 것이지 실행한 것이 아니라는 점을 유의

```
func sayHello() {

    print("Hello)

    print("안녕하세요.)

    print("곤니찌와)

}


```

##### 2) 함수 실행문(call): 실행문을 작성해야 비로소 실행된다.

```
sayHello()

```

### 함수를 왜 사용할까? (함수 사용의 이유)

- 1. 반복되는 동작을 단순화해서 재사용 가능

- 2.  코드를 논리적 단위로 구분 가능

- 3.  코드 길이가 긴 것을 단순화해서 사용 가능

- 4.  미리 함수를 잘 만들어 놓으면, 개발자는 사용만 하면 됨(내부적 내용을 몰라도 사용 가능)

### 함수의 실행문(call)에 대한 인지

- 소괄호 ( )는 함수의 실행이다.

```
print("Hello")


sayHello()

```

> #### **소문자로 시작하고, 뒤에 () 소괄호(퍼렌서시스)가 오면 이것은 함수의 실행문이라는 것을 인지해야 함**

## 함수의 형태

- 1. 함수가 인풋(input)이 있는 경우

> 함수 정의문

```

func saySomething(name: String) {

    print("안녕하세요 \(name) 님")

}

```

> 함수 실행문(call)

```
saySomething(name: "스티브")




var name = "Jobs"


saySomething(name: name)

```

### 2) 함수가 아웃풋(output)이 있는 경우

- 아웃풋 앞에 return이라는 키워드를 사용해야 한다.

```
func sayHelloString() -> String {

    return "안녕하세요"
}



sayHelloString()



print(sayHelloString() + " 잡스 님")



// 함수를 호출하는 것도 표현식이 될 수 있다.(리턴형이 있는 경우)

// (표현식의 결과는 함수가 리턴하는 값)

var name1 = sayHelloString()


```

### 3) 인풋과 아웃풋이 모두 있는 경우

```
// 함수 정의문

// 함수의 아웃풋에는 반드시 하나의 타입만 나올 수 있다.

func plusFuntion(a: Int, b: Int) -> Int {

    let c = a + b

    return c       // 아웃풋이 있는 경우, 리턴키워드를 사용해야함

}




// 함수 실행문(call)

plusFuntion(a: 3, b: 4)



print(plusFuntion(a: 5, b: 6))







// 함수 정의문

func someFuntions(x: Int) -> Int {

    var y = 2 * x + 3

    return y
}



// 함수 실행문(call)

someFuntions(x: 2)





// 함수 정의문

func sayHello1(a: String) -> String {

    var say = "안녕 반가워. \(a)야. 나는 스위프트라고 해."

    return say
}




// 함수 실행문(call)

sayHello1(a: "아이유")

sayHello1(a: "GD")

print(sayHello1(a: "스티브잡스"))





// 함수 정의문

func number5() -> Int {

    return 5

}



// 함수 실행문(call)

number5()

print(number5())


```

### Void 타입의 이해 (아웃풋이 없는 경우)

```

func sayhello1() {

    // Void가 생략되어 있는 상태

    print("Hello, Swift!")
}


func sayhello2() -> Void {

    // Void: 빈, 비어있는. return형이 없는 함수는 이렇게 사용 가능

    print("Hello, Swift!")
}



func sayhello3() -> () {

    print("Hello, Swift!")

}


```

### 리턴 타입이 없는 함수(Void 타입) vs 리턴타입이 있는 함수의 차이 ⭐️

- 리턴 타입이 없는 함수 ➞ 결과는 Void 타입

```
sayhello1()         // 제어권



// 이렇게 사용하는 경우는 없음

// var hello: Void = sayhello1()

// 즉, 결과값이 존재 X

```

> #### **리턴 타입이 있는 함수 ➞ 결국 결과로 "값"이 있는 것 ➞ (일반적으로)사용**

- 함수 자체를 값으로 볼 수 있음

```


print(sayHelloString())       // 제어권 + 결과값


```

## 함수의 파라미터, 아규먼트

- 파라미터(Parameter)

##### 파라미터: 함수를 정의시, 함수 정의에 입력값으로 사용되는 변수(내부사용)

##### 아규먼트: 함수를 호출시, 함수가 필요한 파라미터의 타입과 일치하는 실제 값(외부사용)

> 파라미터 이름만 사용할때(아규먼트 레이블을 사용 안하면)

```
func printName(name: String) {

    // name: String  (파라미터)

    print("나의 이름은 \(name) 입니다.")

}



printName(name: "에디슨")          //   "에디슨" (아규먼트)

```

### 1) 아규먼트 레이블(Argument Label)

```
// 아큐먼트 레이블을 사용하면

func printName1(first name: String) {

    print("나의 이름은 \(name) 입니다.")

}

// 외부에서 보여지는 것은 first(아규먼트 레이블),

// 실제 내부에서 작동하는 것은 name(파라미터)

printName1(first: "뉴턴")





// 아규먼트 레이블을 사용 안하면


func someFunction(first: Int, second: Int) {

    print(first + second)

}


someFunction(first: 1, second: 2)


```

> 아규먼트 레이블을 사용하는 것의 이점:일반적으로 함수를 사용할때 더 명확하게 무엇을 요구하는 지를 알려줄 수 있다.

```
func someFunction1(writeYourFirstNumber a:Int,

                   writeYourSecondNumber b: Int) {

    print(a + b)

}



someFunction1(writeYourFirstNumber: 3, writeYourSecondNumber: 4)


```

### 2) 아규먼트 레이블을 생략해서 사용하는 것도 가능 (와일드카드 패턴)

```

func addPrintFunction(_ firstNum: Int, _ secondNum: Int) {

    print(firstNum + secondNum)
}

// 와일드카드 패턴을 쓰는 이유:전달하고자 하는 바가 명확한 경우에 사용

addPrintFunction(1, 2)

```

### 3) 가변파라미터 - 함수의 파라미터에 정해지지 않은, 여러개의 값을 넣는 것도 가능(Variadic Parameters)

- 1.  하나의 파라미터로 2개 이상의 아규먼트를 전달할 수 있다.

- 2.  아규먼트는 배열형태로 전달된다.

- 3.  가변 파라미터는 개별함수마다 하나씩만 선언할 수있다.(선언 순서는 상관없음)

- 4.  가변 파라미터는 기본값을 가질 수 없다.

```

func arithmeticAverage(_ numbers: Double...) -> Double {

    var total = 0.0     // 4.0

    for n in numbers {

        total += n  // 0.0 + 1.5, 1.5 + 2.5
    }

    return total / Double(numbers.count)    // 4.0 / 2.0 -> 2.0
}



// arithmeticAverage(5, 6, 7, 8, 9)



arithmeticAverage(1.5, 2.5)


```

### 4) 함수의 파라미터에 기본값(디폴트) 정하는 것도 가능

```

func numFunction(num1: Int, num2: Int = 5) -> Int {

    var result = num1 + num2

    // 함수를 실행할때 num2에 아규먼트를 주지 않는다면 기본값으로 5를 준다는 뜻

    return result

}

numFunction(num1: 3)

numFunction(num1: 3, num2: 7)


```

## 함수 사용시 주의점 ⭐️

- 1. 함수의 파라미터에 대한 정확한 이해

```
// 함수의 파라미터

func someAdd(a: Int) -> Int {

    // let a: Int   (값의 변경이 불가능)

    // a = a + 1

    // 변수로 사용하고 싶다면 바인딩 하여 사용       var b = a, return b

    return a
}



someAdd(a: 5)


```

### 2) 함수 내의 변수의 Scope(스코프)

> #### **함수 내에서 선언한 변수의 Scope(범위) ➞ 함수의 바디로 제한됨**

```
func sumOfNum(a: Int) -> Int {

    var sum = 0

    sum += a

    return sum
}

// sum


sumOfNum(a: 3)


```

### 3) return 키워드의 정확한 이해

- return 키워드의 역할

- 1.  리턴타입이 있는 함수의 경우(아웃풋이 있는 경우):

리턴 키워드 다음의 표현식을 평가한 다음에 그 결과를 리턴하면서 함수를 벗어남

- 2.  리턴타입이 없는 함수의 경우(아웃풋이 없는 경우):

함수의 실행을 중지하고 함수를 벗어남 ⭐️

> 리턴 타입이 있는 경우

```
func addFunction(num1: Int, num2: Int) -> Int {

    var result = num1 + num2

    return result
}




addFunction(num1: 3, num2: 4)






func valuationFunction(num: Int) -> Int {

    if num >= 5 {

        return num
    }

    return 0
}



valuationFunction(num: 3)

valuationFunction(num: 5)


```

> 리턴 타입이 없는 경우

```
func numberPrint(n num: Int) {

    if num >= 5 {

        print("숫자가 5이상입니다.")

        return

        /*

         return 타입이 없는데도 불구하고 return을 사용하는 것은

         이 함수를 벗어난다는 의미이다. 즉 함수를 종료한다는 의미이다.

         따라서 리턴 키워드를 사용하면 중괄호 내부의 코드만을 실행하게 된다.

         */


    }

    print("숫자가 5미만입니다.")
}


numberPrint(n: 7)

numberPrint(n: 4)

numberPrint(n: 5)

```

### 4) 리턴타입이 있는 경우, 함수의 실행문의 의미

- 리턴 타입이 있는 함수를 호출하는 경우, 함수를 호출하는 것은 표현식 (표현식의 결과는 함수가 리턴하는 값)

```
func nameString() -> String {

    return "스티브"

}


var yourName: String = nameString()           // "스티브"




if nameString() == "스티브" {

    print("이름이 일치합니다.")

}




// var yourName: () -> String = nameString


```

### 5) 함수의 중첩 사용 - 중첩된 함수(Nested Functions)

- 함수 안에 함수를 작성할 수도 있다.

- (함수 안에 있는 함수는 밖에서 사용이 불가능)

- 함수를 제한적으로 사용하고 싶을 때, 사용

```

func chooseStepFunction(backward: Bool, value: Int) -> Int {

    func stepForward(input: Int) -> Int {
        return input + 1
    }

    func stepBackward(input: Int) -> Int {
        return input - 1
    }

    // 위의 두 함수는 선언문이기 때문에 실행되지 않는다.

    // 실행은 if문으로부터 시작이 되면서부터 위의 두 함수를 실행시키게 된다.

    if backward {

        return stepBackward(input: value)

    } else {

        return stepForward(input: value)
    }

}






var value = 7

// case 1

chooseStepFunction(backward: true, value: value)


// case 2

chooseStepFunction(backward: false, value: value)



```

## 함수 표기법(지칭), 함수의 타입 표기

- 참고) 함수 표기법

```
// 정의문

func doSomething() {

    print("출력")
}



func addPrintFunction(_ firstNum: Int, _ secondNum: Int) {

    print(firstNum + secondNum)

}




// 실행문

numberPrint(n: 3)

```

##### 함수를 지칭하려는 경우, 함수를 어떻게 표기할까?

- 1.  개발자 문서를 읽을 때 필요

- 2.  함수를 지칭할때 필요(함수를 변수에 담거나)

##### 함수의 표기법(함수를 지칭시)

1. 파라미터가 없는 경우, ()를 삭제: 소괄호가 빠져있다면, 함수를 지칭하는 것이다.

```
doSomething

var some = doSomething

some()

```

- some이라는 변수에 doSomething이라는 함수를 담았다.

- 즉 some이라는 변수가 doSomething이라는 함수를 '지칭'한다.

- doSomething이라는 함수를 some이라는 변수로도 실행 가능하다는 것이다.

- some이라는 변수로 실행 시키는 것이 아닌 소괄호를 사용하여 실행 가능하다.

2. 아규먼트 레이블이 있는 경우, 아규먼트 레이블까지를 함수의 이름으로 봄

- 파라미터가 있는 경우에는 타입을 지우고 아규먼트 레이블로 함수를 지칭

```
numberPrint(n:)        //  "numberPrint n 함수이다."

```

3. 파라미터가 여러개인 경우, 콤마없이 아규먼트 이름과 콜론을 표기

```
chooseStepFunction(backward:value:)

// 함수를 지칭함으로서 변수에다가 함수를 담을 수 있다.

```

4. 아규먼트 레이블이 생략된 경우, 아래와 같이 표기 (콤마(,)가 없어야 한다.)

```
addPrintFunction(_:_:)

```

### 함수 타입의 표기

```
// 변수에 정수를 저장하는 경우에 타입 표기

var num: Int = 5




// 함수의 타입 표기 방법

var function1: (Int) -> () = numberPrint(n:)

// 함수의 타입:(Int) -> ()


var function2: (Int, Int) -> () = addPrintFunction(_:_:)

// 함수의 타입: (Int, Int) -> () or Void (Void는 ()로 표현 가능)

// () -> () == () -> Void

// 일반적으로 인풋에는 Void를 쓰지 않는다. 아웃풋에 Void 사용

// 변수가 함수를 가르키도록 할 수 있음

function2(3, 5)

```

## 함수의 오버로딩(overloading)

- 함수의 오버로딩에 대한 이해

> #### **오버로드(overload): 영어로 과적하다라는 뜻**

- 같은 이름의 함수에 매개변수(파라미터)를 다르게 선언하여, 하나의 함수 이름에 실제 여러개의 함수를 대응 시키는 것

- 쉽게 말하면: 함수의 이름의 재사용

- 스위프트는 오버로딩을 지원하는 언어

- ⭐️ 함수이름, 파라미터 수/자료형, 아규먼트 레이블, 리턴형을 모두 포함해서 함수를 식별

```
func doSomething(value: Int) {
    print(value)
}


func doSomething(value: Double) {
    print(value)
}


func doSomething(value: String) {
    print(value)
}


func doSomething(_ value: String) {
    print(value)
}


func doSomethging(value1: String, value2: Int) {
    print(value1, value2)
}




doSomething(value: 5)

doSomething(value: 3.4)

doSomething(value: 3)

```

> 오버로딩을 지원하지 않는 언어의 단점

같은 기능을 제공하는 함수를 파라미터 형식마다

이름을 다르게 구현해야하기 때문에

함수의 이름이 많아지고,구별해서 사용하는 것이 어렵다.

오버로딩을 지원함으로서 함수 이름 하나에

여러개가 대응되도록 만들어 놓으면 일일이 함수의 이름을 외울 필요가 없어진다.

# 함수 Part 2

## 범위(Scope)

- Scope:함수, if, for문 등에 모두 해당

- 1.  변수는 코드에서 선언이 되어야, 그 이하의 코드에서 접근 가능(선언하기 이전에는 접근 불가함) (전역변수는 예외)

- 2.  상위스코프(범위)에 선언된 변수와 상수에 접근가능하며, 하위스코프(범위)에는 접근할 수 없다.

- 3.  (동일한 스코프에서 이름이 중복될 수 없지만, 다른 스코프에서는 이름 중복이 가능)

- 4.  가장 인접한 스코프에 있는 변수와 상수에 먼저 접근 한다.

### 첫번째 예제

```
func greeting1() {

    print("Hello")

    var myName = "홍길동"
    print(myName)

    print(name)

    if true {
        print(myName)
        print(name)
    }
}


// print(myName)

// print(name)




greeting1()

// 원칙은 함수 실행 전에(함수 선언 전이 아닌) name이라는 변수를 선언하는 것이다.

// 실제 앱을 만들때는 name이라는 전역변수를 함수 실행 전에 먼저 선언해 줘야 한다.


var name = "잡스" // 전역변수 (메모리의 데이터 영역에 저장)

// 플레이그라운드 파일이기 때문에 에러가 발생 X. 실제 앱개발에서는 에러 발생


greeting1()

```

### 두번째 예제

```
 var realName = "iOS-Jay"

// 전역 변수로서 미리 선언되어 있었다면 당연히 실행됨

func doSomething() {

 var realName = "앨런"

    print(realName)

    // 코드는 순서대로 작동하기 때문에, 선언이 되어있어야 사용 가능: 조건문에서 배운 프로그래밍의 기본 원칙 첫번쨰 -> 순차

//    var realName = "앨런"

    print(realName)
}


doSomething()

```

### 세번째 예제

```
func sayGreeting1() {

    print("Hello")


    func sayGreeting2() {

        print("Hey")

        if true {

            print("")
        }
    }

    sayGreeting2()  // 내부이니 접근 가능

}


// sayGreeting1()

// sayGreeting2() -> sayGreeting1() 내부에 있는 함수이기 때문에 밖에서 접근이 불가능하다.



```

# 제어전송문 정리

## 1) break

- (1) switch문 (2)반복문(for / while 등) 에서 사용

```

var a = 3

switch a {
case 1:
    break      // 실행하는 문장이 없을때, 반드시 입력 (약속)
case 2:
    print(a)
case 3:
    print("3입니다.")
case 4:
    print("안녕하세요")
default:
    break
}



// 가장 인접한 반복문을 아예 중지 ⭐️

for index in 1...10 {

    if index == 3 {
        break
    }

    print(index)
}


```

## 2) fallthrough

- switch문에서 사용

```
switch a {
case 1:
    break      // 실행하는 문장이 없을때, 반드시 입력 (약속)
case 2:
    print(a)
case 3:
    print("3입니다.")
    fallthrough
case 4:
    print("안녕하세요.")
default:
    break
}


// 3입니다.

// 안녕하세요.



```

## 3) continue

- 반복문에서 사용(for/ while 등)

```
for index in 1...10 {

    if index % 2 != 0 {
        continue
    }

    print(index)

    /* 간단하게 말해 건너뛰라는 뜻.

  continue는 반복문을 다음 싸이클로 보냄

  다음 싸이클에서 계속 지속(continue)하라는 의미

  1) 반복문의 첫번째 index는 1

  2) 1은 2로 나눴을 때 나머지가 1이므로 참

  3) 조건이 참이므로 continue를 만남

  4) continue를 만나므로 print(index)를 실행 시킬 수 없음

  5) 첫 문장을 실행시키지 않고 다음 사이클(index = 2)로 넘어감

  6) 2는 나머지가 0이므로 거짓, 따라서 continue를 실행시키지 않음

  7) 즉 if문을 실행시키지 않고 if문 다음의 print(index)를 실행

  8) 홀수 숫자는 continue를 만나고 짝수는 print 함수를 만남. 짝수가 출력됨



 */
}

```

## 4) return

- 함수에서 사용

```
func doSomething() {

    print("1")

    print("2")

    if true {

        return
    }

    // 리턴 타입이 없으므로 함수의 실행을 중지하고 함수를 벗어남

    print("3")

    print("4")

}


doSomething()

```

## inout 파라미터

- 함수를 통해, 변수를 직접 수정하고 싶은 경우는 어떻게 해야할까?

> #### **함수내의 파라미터는 기본적으로 값타입이고(복사되서 전달) 임시상수이기 때문에 변경 불가 원칙**

```
var num1 = 123     // 전역변수

var num2 = 456     // 전역변수


func swap(a: Int, b: Int) {

// 파라미터는 상수로 선언     let a = ..., let b = ...

//    var c = a     // 123

//    a = b         // a = 456

// a는 상수로 선언이 되있기 때문에 실행이 불가하다.

//    b = c         // b = 123

}


swap(a: num1, b: num2)

```

swap 함수라는 스택프레임을 만들었고,

밖에 있는 전역변수로 선언되어 있는 값들을

복사를 해서 내부에서 사용하게 된다.

그래서 원래의 값을 변경시킬 수 없다.

원래의 데이터를 복사했기 때문에.

파라미터는 기본적으로 값타입(복사되어 전달)

### 함수 내에서 변수를 직접 수정하도록 돕는 inout키워드 (참조로 전달)

- inout 키워드(선언시), & 사용(실행시)

> #### **참조로 전달한다는 뜻은 메모리의 주소를 전달한다는 개념이다.**

```

var num1 = 123

var num2 = 456

func swapNumbers(a: inout Int, b: inout Int) {

    var temp = a

    a = b   // 실질적으로 num1이 전달됨. num1 = b

    b = temp
}

swapNumbers(a: &num1, b: &num2)


print(num1)     // 456

print(num2)     // 123




```

- inout 키워드를 쓰면 그냥 변수를 전달하는구나, 상수로 선언하는 것이 아닌 밖에 있는 변수 그 자체를 전달한다고 알면 된다.

- 함수 실행시에는 앰퍼센트를 꼭 붙여야함(원본이 전달된다는 의미)

- 실행을 할 때는 &(엠퍼센트) 기호를 붙임. 주의하라는 의미(값이 복사된 것이 아닌 주소가 전달되었음을 알려주는 기호)

- 입출력 파라미터는 내부적으로 copy-in, copy-out 메모리 모델을 사용하지만, 실제 원본이 전달된다고 쉽게 생각하면 됨

- copy-in, copy-out값을 복사해서 함수 바디 내부로 전달하고,

- 함수가 종료될때, 아규먼트로 전달한 변수에 복사됨(함수 바디 내부에서 외부로 복사되어 전달)

### inout파라미터 사용시 주의점

1.  상수(let)나, 리터럴 전달하는 것 불가능

- (변하지 않는 값(let)이므로 불가, 직접적으로 123.... 이러한 데이터를 전달해서는 안됨( &123...불가능). 메모리 주소를 전달하는 것이기 때문에 값 자체를 전달하는 것은 안된다.)

2.  파라미터의 기본값 선언을 허용하지 않음

- (값을 바꿀 수 없는 것이니 당연히 선언 불가하다. a: Int = 5... 이런 행위로는 inout키워드 사용이 가능하지 않다.)

3.  가변파라미터(여러개의 파라미터)로 선언하는 것 불가능

## 가드문(Guard Statement)

- 불만족하는 조건을 사전에 걸러내는 조건문

> #### **if문의 단점 - 여러개의 조건이 있을때 코드의 가독성이 문제됨 ➞ guard문으로 단점 극복**

- Swift에서 만든 조건문. 다른 언어에서는 없는 개념

- if문을 만족하는 경우, 지속적인 들여쓰기로 인해 코드의 가속성이 안 좋아질 수 있음

- (실제 프로젝트에서는 코드를 알아보기 힘듬)

### guard문

1.  else문을 먼저 배치 - 먼저 조건을 판별하여 조기 종료(early exit)

2.  조건을 만족하는 경우 코드가 다음 줄로 넘어가서 계속 실행

3.  가드문에서 선언된 변수를 아래문장에서 사용 가능 (동일한 스코프로 취급): guard let 바인딩 관련

### 가드문의 이해

```
func checkNumbersOf1(password: String) -> Bool {

    if password.count >= 6 {

        // 로그인을 처리하는 코드 작성

        // 1

        // 2

        // 3

        // 4

        // 5

        return true

    } else {

        return false

    }

}




func checkNumbersOf2(password: String) -> Bool {

    // 감시하다

    guard password.count >= 6 else {

    // early exit:일찍 종료 시킴

        return false

    // 종료 조건 - 함수 내에서는 return / throw
    }

    // 로그인을 처리하는 코드 작성

    // 1

    // 2

    // 3

    // 4

    // 5

    return true
}


```

> 조건문과 다르게 else문이 먼저 나오는 조건문이라고 생각하면 된다.

### 가드문의 사용 예시

- 반드시 코드를 종료해야 하는 조기 종료의 조건이 필요하므로, 로컬스코프(함수/반복문) 내에서만 사용 가능

```
unc check(words: String) -> Bool {

    guard words.count >= 5 else {

        print("5글자 미만입니다.")

        return false                             // 종료 조건 - 함수 내에서는 return / throw
    }

    print("\(words.count)글자입니다.")

    return true
}



check(words: "안녕하세요")


```

## 함수의 리턴값 유무

- 함수의 정의

> 리턴값(타입)이 없는 함수

```
func sayHello() {

    print("안녕하세요.")

}




// sayHello() 결과값 존재 X(Void). CPU의 제어권만 존재


@discardableResult

// discardable: 버릴 수 있는
func sayHelloString() -> String {

    print("하이")

    return "안녕하세요"     // 결과적으로 출력은 "하이"만 함.

}

sayHelloString()    // 실제 프로젝트에서 경고창 표시: 결과값("안녕하세요".)를 왜 사용하지 않느냐?

```

- 경고창을 없애려면 변수에 담아서 사용하거나 출력(print)을 하거나 와일드 카드 패턴을 사용함.

- \_ = sayHelloString():"안녕하세요" 가 반환이 되는데, 이 값을 생략할 것이라고 말해주는 개념

- 과거 스위프트 버전 4 이하에서 사용하던 개념

- 스위프트 5.2부터 @discardableResult 사용

### 리턴 타입이 없는 함수(Void 타입) vs 리턴타입이 있는 함수의 차이 ⭐️

> #### **리턴 타입이 없는 함수 ➞ 결과는 Void 타입**

```
// 이렇게 사용하는 경우는 없음(결과값 없음)

// var hello: Void = sayhello1()

sayHello()         // 제어권

```

> #### **리턴 타입이 있는 함수 ➞ 결국 결과로 "값"이 있는 것 ➞ (일반적으로)사용**

- 함수 자체를 값으로 볼 수 있음

```
var hello = sayHelloString()       // 제어권 + 결과값

```

### 리턴값이 있는 함수에서 리턴값을 사용하지 않는다면

- 기존의 방식: (결과값을 사용하지 않을때) 지금까지 많이 사용해오던 패턴

```

_ = sayHelloString()

```

> 스위프트 5.2 부터: @discardableResult -> 어트리뷰트를 사용하도록함

# 함수 실행의 메모리 구조

### 3 + 4 = 7 에 대한 이해

```
var a1 = 3

var a2 = 4

var a3 = a1 + a2

print(a3)

```

> ### **3 + 4 = 7을 함수로 정의한다면**

**1) 함수를 정의**

```

func threeAndFour() {

    var a1 = 3

    var a2 = 4

    var a3 = a1 + a2

    print(a3)

}

```

**2) 함수의 실행**

```
threeAndFour()

```

> **함수가 뭘까?**

```
단순화한 프로그램: 3 + 4 = 7

 0번째) 3을 임의의 공간에 저장
 1번째) 4를 임의의 공간에 저장
 2번째) 3과 4를 더해서 임의의 공간에 저장
 3번째) 결과를 출력함

 CPU에서 한줄씩 실행되는 동작을 묶어 이름을 붙인 것에 불과하다.

 threeAndFour:  (x01234)특정메모리주소

 0번째) 3을 임의의 공간에 저장
 1번째) 4를 임의의 공간에 저장
 2번째) 3과 4를 더해서 임의의 공간에 저장
 3번째) 결과를 출력함


 이제 어느 위치에서든지 함수를 실행시키면, 함수의 내용이 순차적으로 실행된다.


```

### 플레이그라운드에 대한 가정 (메모리 구조를 더 잘 이해하기 위함)

[플레이그라운드](https://github.com/ios-Jay/TIL/blob/main/img/playground.png)

- #### **프로그래밍에서, 가장 처음으로 프로그래밍이 시작되는 곳은 main() 메인함수 (스위프트에서는 main.swift파일)**

- #### **플레이 그라운드는 문법을 쉽게 공부하기 위한 목적이므로 main() 함수는 눈에 보이지 않지만, 구현이 되어있다고 가정**

```
func main() {

    var name = "홍길동"

    // 현재 구현하는 곳 ====> 현재의 플레이그라운드:main() 함수의 영역이라고 가정


}


main()    // 앱을 키면 ====> 프로그램을 실제 시작시킴


```

### addTwoNumbers(a: Int, b: Int) 함수

> #### **main() 함수의 영역이라고 가정**

```
func addTwoNumbers(a: Int, b: Int) -> Int {

    var c = a + b

    return c
}



var num1 = 5    // 이 예제에서는 전역변수가 아닌 main()함수의 영역이라고 가정

var num2 = 3    // 이 예제에서는 전역변수가 아닌 main()함수의 영역이라고 가정

var num3 = addTwoNumbers(a: num1, b: num2)

print(num3)

/* 컴파일 된 경우

 코드 영역: 앱 실행시 모든 코드가 일단 코드 영역에 올라감. 순차적으로 코드 실행

 print:

 ...
 ...
 ...

 addTwoNumbers:

 임시공간을 만든다.
 a라는 상수에 Int(값)을 저장한다.
 b라는 상수에 Int(값)을 저장한다.
 c라는 변수 공간을 만든다.
 a + b를 더해서 임시값을 가진다.
 임시값을 c에 저장한다.
 c를 리턴(반환)한다.

 MAIN:

 num1 이라는 변수에 5를 저장한다.
 num2 이라는 변수에 3을 저장한다.
 num3 이라는 변수 공간을 만든다.
 (num1과, num2를 이용) addTwoNumbers 함수를 실행 -> 실행하는 함수의 스택에 주소 저장 -> 함수를 찾아감
 결과값을 num3 공간에 저장한다.
 (num3을 이용) print 함수를 실행


```

#### 설명:

항상 프로그램을 실행 시키면 MAIN 함수 영역이 생성된다.
왜냐하면 프로그램을 실행을 시키면 CPU는 어디서부터 실행 시킬지
어떤 줄의 명령어부터 실행시킬지 알아야 하기 때문에 MAIN 영역을 생성한다.
그래서 앱을 실행시키면 CPU는 MAIN 영역을 찾아가서 코드를 순차적으로 실행한다.
그리고 실행하는 함수의 스택에 주소를 저장한다. CPU는 주소를 저장해야 한다.
왜냐하면 함수를 실행하고 다시 제자리로 돌아와야 하기 때문이다.
함수를 찾아간뒤 그 함수를 실행한다. CPU가 함수를 순차적으로 코드를 실행한다.
함수를 모두 실행하고 나면 CPU가 제어권(코드를 실행시키는 것)과 값(return)도
MAIN 영역에 돌려주게된다.
그리고 다시 MAIN 영역에서 코드를 순차적으로 실행 시킨다.

#### 과정:

- CPU가 메모리에서 MAIN 영역을 실행 시킴

- 그 결과 스택에서 main() 함수의 영역 생성: 스택 프레임

- 스택 프레임: main 함수가 실행될 영역의 공간을 만든다는 것

- 순차적으로 코드를 실행시킨뒤(num1 -> num2 -> ...) 함수를 실행시키면 마치 층을 쌓듯이 올라가서 함수(addTwoNumbers) 라는 또다른 스텍프레임을 생성한다.

- 스택프레임 생성후 CPU는 저장된 주소를 통해 함수를 찾아간다.

- 찾아간뒤 제일 먼저 복귀주소를 함수에 저장한다. 함수를 종료시킨뒤 다시 코드를 실행시키기 위해 어디로 찾아가야할지에 대한 명령어의 주소를 저장한다.

- 그런 다음 함수값 / 임시값에 대한 임시공간을 만든다. 임시공간을 만드는 이유는 addTwoNumbers 함수의 경우 리턴 타입이 있는 경우이므로 결과값을 반환해야 하기 때문이다. 리턴 타입이 없는 함수의 경우 이러한 공간을 만들지 않는다. 반환할 필요가 없기 때문에.

- 그런 다음 파라미터의 공간을 형성한다. 파라미터는 상수로 선언되었기 때문에 변경 X

- a(let a = 5)와 b(let b = 3)를 더하고 그 값을 c(var c = a + b)에 저장한다.

- 그런 다음 return을 만나고 임시공간에 8이 저장 된다.

- 함수의 실행이 끝나면 함수의 스택프레임(addTwoNumbers)이 사라지고, 8이라는 값을 반환을 하면서 main() 함수 영역을 찾아가고 num3에 값을 저장한다.

- 그런 다음 print를 실행한다. print도 함수이기 때문에 MAIN 영역에서 Print 함수의 영역을 찾아간다. 그렇기 때문에 복귀주소를 저장하고 함수의 실행에 필요한 메모리 공간을 사용한다. print 함수가 종료되면 스택프레임이 사라진다.

- 프로그램이 종료되면 main() 영역 역시 사라진다.

#### 정리:

##### **Stack: 차곡 차곡 아래에서부터 쌓이고, 제거 할때는 위에서부터 제거할 수 있는 구조**

- 함수의 실행이란 그 함수 자체가 필요한 메모리 공간, 즉 스택 프레임을 만드는 것을 하는 것이다.

- 스택 프레임을 만들어서 어떤 일처리를 하고, 그 일처리가 다 끝나면 그 스택 프레임이 사라지게 된다.

- 프린트도 프린트 함수이기 때문에 스택 프레임 공간에 복귀 주소를 만들어 놓고 실행이 끝나면 프린트의 스택 프레임 영역이 사라지게 된다.

## 예시를 통한 이해

- 함수 실행시, 실제 메모리에서 어떻게 동작할까?

> #### **메모리 예제:Scope에 대하여**

```
var total: Int = 0    // 실제 전역변수라면 (데이터영역에 저장됨)


func square(_ i: Int) -> Int {     // x 제곱

    return i * i
}


func squareOfSum(_ x: Int, _ y: Int) -> Int {    // (x + y)(x + y)

    var z = square(x + y)

    return z

}


func startFunction() {

    var a = 4

    var b = 8

    total = squareOfSum(a, b)
}

// func main()   여기서부터가 메인함수 영역

startFunction()

/* startFunction() 함수의 실행 메모리 구조

 코드: 앱 실행시 모든 코드가 일단 코드 영역에 올라감. 순차적으로 코드 실행

 square 함수:

 상수를 선언
 두 수를 곱한다.
 리턴한다.

 squreOfSum 함수:

 상수 2개를 선언
 변수를 하나 만듦
 square()
 값을 저장
 리턴한다.

 startFunction함수:
 변수 2개를 선언/값저장
 squareOfSum(...)

 main()
 var total: Int = 0
 startFunction()


```

#### 과정:

- var total: Int = 0을 전역변수라고 가정

- main() 함수를 찾아감. 스택 프레임 생성

- 전역변수를 생성. 데이터 영역에 저장 total = 0

- startFunction() 함수를 실행. 스택 프레임 생성

- 변수 2개를 선언하고 값을 저장. 복귀 주소 역시 당연히 저장됨.

- squareOfSum() 함수 주소를 찾아가서 실행. squareOfSum() 함수 스택프레임 생성

- squareOfSum() 함수가 리턴형이 있기때문에 임시값을 만든다.

- 파라미터 x(let x = 4), y(let y = 8) 생성

- 변수 생성(var z = square(x + y)

- square() 함수를 찾아감. square() 함수 스택프레임 형성

- 임시공간 생성(리턴), i(let i = 12) 생성. 결과값( i _ i = 12 _ 12) 생성

- 결과를 리턴하면서 squareOfSum() 함수의 z에 저장.

- square() 함수 종료. 스택프레임 제거. 리턴값을 임시공간에 저장

- startFunction에 임시값을 전달. squareOfSum() 함수 스택프레임 제거

- 결과값 144를 데이터 영역의 있는 전역변수 total에 저장

- startFuntion 함수 종료

#### 정리:

- 데이터 영역과 힙 영역은 공유되는 부분. 그래서 어디에서나 접근 가능

- 그러나 스택 영역은 공유되는 부분이 아니다.

- 그래서 스택프레임은 자기 내부에서만 변수를 사용할 수 있다.

- 스택프레임이라는 고유의 공간의 개념이 바로 Scope에 대한 이해.

### 함수와 변수의 변화 예제

```



var a = 1       // 실제 전역변수라면

var b = 1       // 실제 전역변수라면


func addOneMore2() -> Int {

    b += 1

    return 5
}


func addOneMore1() {

    var num = 0

    a += 1

    num += addOneMore2()    // 5

    print(num)

}



addOneMore1()

// a

// b

/* 정리

 코드: 앱 실행시, 모든 코드가 일단 코드영역에 올라감. 그리고 순차적으로 한줄씩 실행

 print 함수:

 출력하기

 addOneMore2함수:

 b에 1 더하기
 5를 리턴

 addOneMore1함수:

 변수 1개를 선언/값저장
 a에 1 더하기
 addOneMore2()
 print()

 main()

 var a = 1
 var b = 1
 addOnemore1()

 */

```

#### 과정:

- main() 함수가 실행이 되고 전역변수가 순차적으로 데이터 영역에 저장

- var a = 1, b = 2. 데이터와 힙 영역은 공유되는 영역

- addOneMore() 함수 실행. 스택프레임 형성

- 프레임 내부에서 num = 0 형성

- a에 1을 더함 var a = 2

- addOneMore2() 함수 실행. 스택프레임 형성. 리턴형이 있으므로 임시공간 생성

- b에 1을 더함 var b = 2

- 5를 리턴. addOneMore2() 함수 실행 종료. 스택프레임 제거

- num에 5를 저장

- print(num) 실행. print 함수 이므로 주소를 찾아간뒤 print() 스택 프레임 형성

- print(num) 함수 종료. 순차적으로 main() 함수 역시 종료

# 문자열 중에서 랜덤 뽑아내기 / 소수 판별

## 1) 랜덤 문자열 뽑아내는 함수

- 문자열을 입력하면 그중 한개의 글자를 랜덤으로 뽑아주는 함수를 만들어 보자!

```
func chooseRandomString(_ chars: String) -> String {

    // chars.randomElement()

    // let randomString = String(chars.randomElement()!)

    return String(chars.randomElement()!)

}


chooseRandomString("abcdefg")

```

## 2) 소수를 판별하는 함수

- 소수, 즉 1과 자기 자신만으로 나누어 떨어지는 1보다 큰 양의 정수를 판별하는 함수를 만들어보기

```
// 소수판별을 for문으로 구현하기

var num = 97

var isPrime: Bool = true   // 깃발


for i in 2..<num {

    if num % i == 0 {
        isPrime = false
        break
    }
}


if isPrime {
    print("소수입니다.")
} else {
    print("소수가 아닙니다.")
}







// 소수 여부를 알려주는 함수 ==========================

func primeNumberCheck(num: Int) -> Bool {

    for i in 2..<num {

        if num % i == 0 {

            return false
        }
    }
    return true
}



if primeNumberCheck(num: 7) {

    print("소수입니다.")

} else {

    print("소수가 아닙니다.")
}




// 소수를 판별해서 프린트까지 해주는 함수 =================

func primeNumber(num: Int) {

    for i in 2..<num {

        if num % i == 0 {

            print("소수가 아닙니다.")

            return
        }
    }

    print("소수입니다.")
}



primeNumber(num: 97)



```

## 팩토리얼 구현하기

#### 고등학교 수학에서의 팩토리얼 개념

- 5! = 5 x 4 x 3 x 2 x 1

- 4! = 4 x 3 x 2 x 1

- n! == n _ (n-1) _ ... \* 1 ( n >= 1 )

### 팩토리얼을 함수로 구현

- 어떻게 반복하도록 만들면 될까?

```

func factorial(num: Int) -> Int {

    var sum = 1

    for i in 1...num {

        sum = sum * i
    }

    return sum
}



factorial(num: 5)



```

## 재귀함수

- 자기 자신을 반복해서 호출하는 함수

> #### _재귀함수: 자기 자신을 반복해서 호출하는 함수_

```

func factorialF(num: Int) -> Int {

    if num <= 1 {

        return 1
    }
    return num * factorialF(num: num - 1)
}


factorialF(num: 5)


```

> #### _재귀함수를 구현할 때는 자칫 잘못하면, 스택오버플로우 현상이 일어날 수 있으므로 주의_
