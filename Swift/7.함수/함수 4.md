# 함수 Ⅳ

## inout 파라미터

- 함수를 통해, 변수를 직접 수정하고 싶은 경우는 어떻게 해야할까?

> #### _함수내의 파라미터는 기본적으로 값타입이고(복사되서 전달) 임시상수이기 때문에 변경 불가 원칙_

swap 함수라는 스택프레임을 만들었고, 밖에 있는 전역변수로 선언되어 있는 값들을

복사를 해서 내부에서 사용하게 된다. 그래서 원래의 값을 변경시킬 수 없다.

원래의 데이터를 복사했기 때문에.

파라미터는 기본적으로 값타입(복사되어 전달)

```

var num1 = 123     // 전역변수

var num2 = 456     // 전역변수


func swap(a: Int, b: Int) {

    // 파라미터는 상수로 선언     let a = ..., let b = ...

    //    var c = a     // 123

    //    a = b         // a = 456

    //    a는 상수로 선언이 되있기 때문에 실행이 불가하다.

    //    b = c         // b = 123
}



swap(a: num1, b: num2)

```

### 함수 내에서 변수를 직접 수정하도록 돕는 inout키워드 (참조로 전달)

#### _inout 키워드(선언시), & 사용(실행시)_

```
num1 = 123

num2 = 456

// 참조로 전달한다는 뜻은 메모리의 주소를 전달한다는 개념이다.


func swapNumbers(a: inout Int, b: inout Int) {

    var temp = a

    a = b   // 실질적으로 num1이 전달됨. num1 = b

    b = temp
}

// inout 키워드를 쓰면 그냥 변수를 전달하는구나, 상수로 선언하는 것이 아닌 밖에 있는 변수 그 자체를 전달한다고 알면 된다.


// 함수 실행시에는 앰퍼센트를 꼭 붙여야함(원본이 전달된다는 의미)

swapNumbers(a: &num1, b: &num2)

// 실행을 할 때는 &(엠퍼센트) 기호를 붙임. 주의하라는 의미(값이 복사된 것이 아닌 주소가 전달되었음을 알려주는 기호)

print(num1)

print(num2)

```

- 입출력 파라미터는 내부적으로 copy-in, copy-out 메모리 모델을 사용하지만, 실제 원본이 전달된다고 쉽게 생각하면 됨

- copy-in, copy-out값을 복사해서 함수 바디 내부로 전달하고,

- 함수가 종료될때, 아규먼트로 전달한 변수에 복사됨(함수 바디 내부에서 외부로 복사되어 전달)

##### inout파라미터 사용시 주의점

1. 상수(let)나, 리터럴 전달하는 것 불가능

(변하지 않는 값(let)이므로 불가, 직접적으로 123.... 이러한 데이터를 전달해서는 안됨( &123...불가능). 메모리 주소를 전달하는 것이기 때문에 값 자체를 전달하는 것은 안된다.)

2.  파라미터의 기본값 선언을 허용하지 않음

(값을 바꿀 수 없는 것이니 당연히 선언 불가하다. a: Int = 5... 이런 행위로는 inout키워드 사용이 가능하지 않다.)

3.  가변파라미터(여러개의 파라미터)로 선언하는 것 불가능

# Guard문

## 가드문(Guard Statement)

- 불만족하는 조건을 사전에 걸러내는 조건문

#### _if문의 단점: 여러개의 조건이 있을때 코드의 가독성이 문제됨 ➞ guard문으로 단점 극복_

- Swift에서 만든 조건문. 다른 언어에서는 없는 개념

- if문을 만족하는 경우, 지속적인 들여쓰기로 인해 코드의 가속성이 안 좋아질 수 있음

- (실제 프로젝트에서는 코드를 알아보기 힘듬)

#### guard문

1. else문을 먼저 배치 - 먼저 조건을 판별하여 조기 종료(early exit)

2. 조건을 만족하는 경우 코드가 다음 줄로 넘어가서 계속 실행

3. 가드문에서 선언된 변수를 아래문장에서 사용 가능 (동일한 스코프로 취급): guard let 바인딩 관련

### 가드문의 이해

```

func checkNumbersOf1(password: String) -> Bool {

    if password.count >= 6 {

        // 로그인을 처리하는 코드 작성

        // 1

        // 2

        // 3

        // 4

        // 5

        return true

    } else {

        return false

    }

}




func checkNumbersOf2(password: String) -> Bool {

    // 감시하다

    guard password.count >= 6 else {

    // early exit:일찍 종료 시킴

        return false

    // 종료 조건 - 함수 내에서는 return / throw

    }

    // 로그인을 처리하는 코드 작성

    // 1

    // 2

    // 3

    // 4

    // 5

    return true
}

```

###### 조건문과 다르게 else문이 먼저 나오는 조건문이라고 생각하면 된다.

### 가드문의 사용 예시

- 반드시 코드를 종료해야 하는 조기 종료의 조건이 필요하므로, 로컬스코프(함수/반복문) 내에서만 사용 가능

```
func check(words: String) -> Bool {

    guard words.count >= 5 else {

        print("5글자 미만입니다.")

        return false                             // 종료 조건 - 함수 내에서는 return / throw
    }

    print("\(words.count)글자입니다.")

    return true
}



check(words: "안녕하세요")

```

## 함수의 리턴값 유무

- 함수의 정의

##### 리턴값(타입)이 없는 함수

```
func sayHello() {

    print("안녕하세요.")

}

```

##### 리턴값(타입)이 있는 함수

- @discardableResult: 버릴 수 있는 이라는 뜻. 버릴 수 있는 결과라는 뜻

```
func sayHelloString() -> String {

    print("하이")

    return "안녕하세요"

}


sayHelloString()     // 실제 프로젝트에서 경고창 표시

// _ = sayHelloString():"안녕하세요" 가 반환이 되는데, 이 값을 생략할 것이라고 말해주는 개념

// 과거 스위프트 버전 4 이하에서 사용하던 개념

// 스위프트 5.2부터 @discardableResult 사용

```

### 리턴 타입이 없는 함수(Void 타입) vs 리턴타입이 있는 함수의 차이 ⭐️

#### _리턴 타입이 없는 함수 ➞ 결과는 Void 타입_

```
// 이렇게 사용하는 경우는 없음(결과값 없음)

// var hello: Void = sayhello1()

    sayHello()         // 제어권

```

#### _리턴 타입이 있는 함수 ➞ 결국 결과로 "값"이 있는 것 ➞ (일반적으로)사용_

- 함수 자체를 값으로 볼 수 있음

```
var hello = sayHelloString()       // 제어권 + 결과값

```

### 리턴값이 있는 함수에서 리턴값을 사용하지 않는다면

##### 기존의 방식

```


_ = sayHelloString()

// (결과값을 사용하지 않을때) 지금까지 많이 사용해오던 패턴


```

##### 스위프트 5.2 부터

```
// @discardableResult   // 어트리뷰트를 사용하도록함

```
