# 함수 Ⅲ

## 함수 실행의 메모리 구조

- 플레이 그라운드에 대한 가정 (메모리 구조를 더 잘 이해하기 위함)

- #### 프로그래밍에서, 가장 처음으로 프로그래밍이 시작되는 곳은 main() 메인함수 (스위프트에서는 main.swift파일)

- #### 플레이 그라운드는 문법을 쉽게 공부하기 위한 목적이므로 main() 함수는 눈에 보이지 않지만, 구현이 되어있다고 가정

```
func main() {

    var name = "홍길동"

    // 우리가 현재 구현하는 곳 ====> 현재의 플레이그라운드


}


main()    // 앱을 키면 ====> 프로그램을 실제 시작시킴

```

### addTwoNumbers(a: Int, b: Int) 함수

```
func addTwoNumbers(a: Int, b: Int) -> Int {

    var c = a + b

    return c
}



var num1 = 5    // 이 예제에서는 전역변수가 아닌 main()함수의 영역이라고 가정

var num2 = 3    // 이 예제에서는 전역변수가 아닌 main()함수의 영역이라고 가정

var num3 = addTwoNumbers(a: num1, b: num2)

print(num3)

```

> ### 컴파일 된 경우

> #### 코드 영역: 앱 실행시 모든 코드가 일단 코드 영역에 올라감. 순차적으로 코드 실행

```
print:

 ...
 ...
 ...





addTwoNumbers:

임시공간을 만든다.
a라는 상수에 Int(값)을 저장한다.
b라는 상수에 Int(값)을 저장한다.
c라는 변수 공간을 만든다.
a + b를 더해서 임시값을 가진다.
임시값을 c에 저장한다.
c를 리턴(반환)한다.

MAIN:

num1 이라는 변수에 5를 저장한다.
num2 이라는 변수에 3을 저장한다.
num3 이라는 변수 공간을 만든다.
(num1과, num2를 이용) addTwoNumbers 함수를 실행 -> 실행하는 함수의 스택에 주소 저장 -> 함수를 찾아감
결과값을 num3 공간에 저장한다.
(num3을 이용) print 함수를 실행
```

> ### 항상 프로그램을 실행 시키면 main 함수 영역이 생성된다.

- 왜냐하면 프로그램을 실행을 시키면 CPU는 어디서 부터 실행 시킬지 어떤 줄의 명령어부터 실행시킬지 알아야 하기 때문에 MAIN 영역을 생성한다.

- 그래서 앱을 실행시키면 CPU는 MAIN 영역을 찾아가서 코드를 순차적으로 실행한다.

- 그리고 실행하는 함수의 스택에 주소를 저장한다.

- CPU는 주소를 저장해야 한다.왜냐하면 함수를 실행하고 다시 제자리로 돌아와야 하기 때문이다.

- 함수를 찾아간뒤 그 함수를 실행한다.

- CPU가 함수를 순차적으로 코드를 실행한다.

- 함수를 모두 실행하고 나면 CPU가 제어권(코드를 실행시키는 것)과 값(return)도 main() 영역에 돌려주게된다.

- 그리고 다시 main() 영역에서 다시 코드를 순차적으로 실행 시킨다.

### 과정:

- CPU가 메모리에서 MAIN 영역을 실행 시킴

- 그 결과 스택에서 main() 함수의 영역 생성: 스택 프레임

- 스택 프레임: main 함수가 실행될 영역의 공간을 만든다는 것

- 순차적으로 코드를 실행시킨뒤(num1 -> num2 -> ...) 함수를 실행시키면 마치 층을 쌓듯이 올라가서 함수(addTwoNumbers) 라는 또다른 스텍프레임을 생성한다.

- 스택프레임 생성후 CPU는 저장된 주소를 통해 함수를 찾아간다.

- 찾아간뒤 제일 먼저 복귀주소를 함수에 저장한다. 함수를 종료시킨뒤 다시 코드를 실행시키기 위해 어디로 찾아가야할지에 대한 명령어의 주소를 저장한다.

- 그런 다음 함수값 / 임시값에 대한 임시공간을 만든다. 임시공간을 만드는 이유는 addTwoNumbers 함수의 경우 리턴 타입이 있는 경우이므로 결과값을 반환해야 하기 때문이다. 리턴 타입이 없는 함수의 경우 이러한 공간을 만들지 않는다. 반환할 필요가 없기 때문에.

- 그런 다음 파라미터의 공간을 형성한다. 파라미터는 상수로 선언되었기 때문에 변경 X

- a(let a = 5)와 b(let b = 3)를 더하고 그 값을 c(var c = a + b)에 저장한다.

- 그런 다음 return을 만나고 임시공간에 8을 저장이된다.

- 함수의 실행이 끝나면 함수의 스택프레임(addTwoNumbers)이 사라지고, 8이라는 값을 반환을 하면서 main() 함수 영역을 찾아가고 num3에 값을 저장한다.

- 그런 다음 print를 실행한다. print도 함수이기 때문에 MAIN 영역에서 Print 함수의 영역을 찾아간다. 그렇기 때문에 복귀주소를 저장하고 함수의 실행에 필요한 메모리 공간을 사용한다. print 함수가 종료되면 스택프레임이 사라진다.

- 프로그램이 종료되면 main() 영역 역시 사라진다.

### 정리:

Stack: 차곡 차곡 아래에서부터 쌓이고, 제거 할때는 위에서부터 제거할 수 있는 구조

함수의 실행이란 그 함수 자체가 필요한 메모리 공간,

즉 스택 프레임을 만드는 것을 하는 것이다.

스택 프레임을 만들어서 어떤 일처리를 하고,

그 일처리가 다 끝나면 그 스택 프레임이 사라지게 된다.

프린트도 프린트 함수이기 때문에 스택 프레임 공간에

복귀 주소를 만들어 놓고 실행이 끝나면 프린트의 스택 프레임 영역이 사라지게 된다.

## 예시를 통한 이해

- 함수 실행시, 실제 메모리에서 어떻게 동작할까?

```

var total: Int = 0    // 실제 전역변수라면 (데이터영역에 저장됨)


func square(_ i: Int) -> Int {     // x 제곱

    return i * i
}


func squareOfSum(_ x: Int, _ y: Int) -> Int {    // (x + y)(x + y)

    var z = square(x + y)

    return z

}


func startFunction() {

    var a = 4

    var b = 8

    total = squareOfSum(a, b)
}

```

> func main() 여기서부터가 메인함수 영역

```
startFunction()

```

### startFunction() 함수의 실행 메모리 구조

> #### 코드: 앱 실행시 모든 코드가 일단 코드 영역에 올라감. 순차적으로 코드 실행

```
square 함수:

상수를 선언
두 수를 곱한다.
리턴한다.

squreOfSum 함수:

상수 2개를 선언
변수를 하나 만듦
square()
값을 저장
리턴한다.

startFunction함수:
변수 2개를 선언/값저장
squareOfSum(...)

main()
var total: Int = 0
startFunction()

```

> #### 과정:

- var total: Int = 0을 전역변수라고 가정

- main() 함수를 찾아감. 스택 프레임 생성

- 전역변수를 생성. 데이터 영역에 저장 total = 0

- startFunction() 함수를 실행. 스택 프레임 생성

- 변수 2개를 선언하고 값을 저장. 복귀 주소 역시 당연히 저장됨.

- squareOfSum() 함수 주소를 찾아가서 실행. squareOfSum() 함수 스택프레임 생성

- squareOfSum() 함수가 리턴형이 있기때문에 임시값을 만든다.

- 파라미터 x(let x = 4), y(let y = 8) 생성

- 변수 생성(var z = square(x + y)

- square() 함수를 찾아감. square() 함수 스택프레임 형성

- 임시공간 생성(리턴), i(let i = 12) 생성. 결과값( i _ i = 12 _ 12) 생성

- 결과를 리턴하면서 squareOfSum() 함수의 z에 저장.

- square() 함수 종료. 스택프레임 제거. 리턴값을 임시공간에 저장

- startFunction에 임시값을 전달. squareOfSum() 함수 스택프레임 제거

- 결과값 144를 데이터 영역의 있는 전역변수 total에 저장

- startFuntion 함수 종료

> ##### 정리:

- 데이터 영역과 힙 영역은 공유되는 부분. 그래서 어디에서나 접근 가능

- 그러나 스택 영역은 공유되는 부분이 아니다.

- 그래서 스택프레임은 자기 내부에서만 변수를 사용할 수 있다.

> ##### 스택프레임이라는 고유의 공간의 개념이 바로 Scope에 대한 이해.

### 함수와 변수의 변화 예제

```

var a = 1       // 실제 전역변수라면

var b = 1       // 실제 전역변수라면


func addOneMore2() -> Int {

    b += 1

    return 5
}


func addOneMore1() {

    var num = 0

    a += 1

    num += addOneMore2()

    print(num)

}



addOneMore1()

```

### 정리

> #### 코드: 앱 실행시, 모든 코드가 일단 코드영역에 올라감. 그리고 순차적으로 한줄씩 실행

```
print 함수:

출력하기

addOneMore2함수:

b에 1 더하기
5를 리턴

addOneMore1함수:

변수 1개를 선언/값저장
a에 1 더하기
addOneMore2()
print()

main()

var a = 1
var b = 1
addOnemore1()

```

> #### 과정:

- main() 함수가 실행이 되고 전역변수가 순차적으로 데이터 영역에 저장

- var a = 1, b = 2. 데이터와 힙 영역은 공유되는 영역

- addOneMore() 함수 실행. 스택프레임 형성

- 프레임 내부에서 num = 0 형성

- a에 1을 더함 var a = 2

- addOneMore2() 함수 실행. 스택프레임 형성. 리턴형이 있으므로 임시공간 생성

- b에 1을 더함 var b = 2

- 5를 리턴. addOneMore2() 함수 실행 종료. 스택프레임 제거

- num에 5를 저장

- print(num) 실행. print 함수 이므로 주소를 찾아간뒤 print() 스택 프레임 형성

- print(num) 함수 종료. 순차적으로 main() 함수 역시 종료

## 조건문과 반복문의 명령어(CPU)구조

### 조건문(if문)

```
var c = 0

func someConditionalStatement(a: Int) {

    if a >= 0 {

        c += 1

    } else {

        c += 7
    }
}


someConditionalStatement(a: -3)

```

- 스택 프레임을 만드는 것은 함수의 실행일뿐이다.

- 스택 프레임을 만들고 그 안에 메모리 공간을 만드는 것은 오직 함수의 실행만 해당함.

- 조건문이나 반복문은 스택 프레임을 만드는 행위가 아니다.

### 반복문

```
var d = 0

func someLoop() {

    for i in 1...5 {

        d += i
    }
}


someLoop()

```
