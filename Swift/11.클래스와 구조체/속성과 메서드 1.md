# 속성과 메서드 Ⅰ

## 1) 저장속성(Stored Properties) / 지연 저장 속성

- 1-1) 저장 속성(Stored Properties)

> #### _값이 저장되는 일반적인 속성(변수)을 저장 속성이라고 함_

그동안 우리가 배운 속성은 정확한 의미에서 "저장 속성"이었음

====> 앞으로 저장 속성이 아닌 것을 배우게 됨

저장 속성이 아닌 다른 속성들은 메모리 공간을 가지지 않는 경우도 있다.

어떤 특정한 메모리 공간을 가지고 그 안에 값을 저장할 수 있는 속성을

바로 저장 속성이라고 한다.

```
struct Bird {

    var name: String

    var weight: Double

    init(name: String, weight: Double) {

        // 기본값이 없으면, 생성자를 통해 값을 반드시 초기화해야함

        self.name = name

        self.weight = weight
    }

    func fly() {
        print("날아갑니다.")
    }
}

var aBird = Bird(name: "참새1", weight: 0.2)

aBird.name

aBird.weight = 0.3



var bBird = Bird(name: "참새2", weight: 0.3)

bBird.name

bBird.weight

```

### 주의점

- 저장 속성 ===> 구조체, 클래스 동일

- let(상수) 또는 var(변수)로 선언 가능

  (만약 저장 속성을 let으로 선언하면 값을 바꿀 수 없음)

- 저장 속성(변수)은 각 속성 자체가 고유의 메모리 공간을 가짐 ⭐️

- (앞에서 배웠던 것처럼) 초기화 이전에 값을 가지고 있거나, 생성자 메서드를 통해 값을 반드시 초기화 해야만 함. 아니면 옵셔널 타입으로 선언하여 nil로 초기화 되도록 할 수도있다.

### 1-2) 지연 저장 속성(Lazy Stored Properties)

```
struct Bird1 {

    var name: String

    // 처음에는 메모리 공간이 없다가 나중에 인스턴스를 선언할 떄 메모리 공간을 생성

    // 하므로, 즉 변화하는 식별자이므로 let으로 선언할 수가 없다.

    // 지연 저장 속성은 무조건 초기 값을 가져야 한다.

    // lazy var weight: Double,

    lazy var weight: Double = 0.2

    // 표현식도 할당 가능. 일반적으로 잘 사용하지 않음

    init(name: String) {
        self.name = name

//        self.weight = weight -> 불가. 무조건 초기값을 가져야 함

//        self.weight = 0.2 -> 가능은 하지만 의미 없음. 어짜피 처음부터 메모리 공간을 만들어 내지 않으므로. 인스턴스를 호출한 이후 생성됨

    }

    func fly() {

        print("날아갑니다.")

    }
}



var aBird1 = Bird1(name: "새")   // weight 속성 초기화 안됨

aBird1.weight  // <============ 해당 변수에 접근하는 이 시점에 초기화됨 (메모리 공간이 생기고 숫자가 저장됨)

```

##### 저장 속성은 저장 속성인데, 지연(lazy)의 의미가 뭘까?

- 지연 저장 속성은 "해당 저장 속성"의 초기화를 지연시키는 것임

- 즉, 인스턴스가 초기화되는 시점에 해당 속성이 값을 갖고 초기화되는 것이 아니라(메모리에 공간과 값을 갖는 것이 아니라), 해당 속성(변수)에 접근하는 순간에 (해당 저장 속성만)개별적으로 초기화됨

- 따라서, 상수로의 선언은 안되고 변수(var)로의 선언만 가능

  ➡︎ lazy var만 가능(lazy let 불가능)

- 즉, 위의 weight이라는 속성은 초기화 시점에 메모리 공간이 생기는 것이 아님

- 예를 들어, 인스턴스가 생기고 난 후, aBird.weight 이렇게 접근하는 순간 메모리 공간을 만들고 숫자를 저장 하게됨

### 주의점

> #### _지연 저장 속성은 "선언시점에 기본값을 저장"해야함_

- 따라서, 생성자에서 초기화를 시키지 않기 때문에 "선언시점에 기본값을 저장"해야함

- 지연(lazy) 저장 속성 ===> 구조체, 클래스 동일

- 값을 넣거나, 표현식(함수 실행문)을 넣을수 있음(모든 형태의 표현식)

- 함수호출 코드, 계산코드, 클로저 코드 등도 모두 가능

  ===> 저장하려는 속성과 "리턴형"만 일치하면 됨

- 지연 저장 속성으로 선언된 "해당 속성"의 초기화 지연.

  ===> 메모리 공간이 없다가 처음 접근하는 순간에 (해당 속성만)개별적으로 초기화됨

### 실제, 지연 저장 속성을 사용하는 이유?

```

class AView {

    var a: Int

    // 1) 메모리를 많이 차지할때

    lazy var view = UIImageView()     // 객체를 생성하는 형태

    // 2) 다른 속성을 이용해야할때(다른 저장 속성에 의존해야만 할때)

    lazy var b: Int = {
        return a * 10
    }()

    init(num: Int) {
        self.a = num
    }
}


```

##### 지연 저장 속성을 사용하는 이유

###### 1)

- 메모리 공간을 많이 차지하는 이미지 등의 속성에 저장할때,

- (반드시 메모리에 다 올릴 필요가 없으므로) 지연 저장 속성으로
  선언 함 (메모리 낭비 막기 위함)

###### 2)

- 다른 속성들을 이용해야 할때

- 초기화 시점에 모든 속성들이 동시에 메모리 공간에 저장되므로 어떤 한가지 속성이 다른 속성에 접근할 수가 없다.

- (그렇지만, 지연 저장 속성을 이용 하는 경우 지연으로 저장된 속성은 먼저 초기화된 속성에 접근 할 수 있게됨)

- 실제 프로젝트에서 많이 활용

- 실제 프로젝트를 다루면서 자연스럽게 이해되는 내용

- (클로저의 실행문 부분도 연결해서 설명 예정)

## 2) 계산속성(Computed Properties)

- 계산속성이라는 것이 왜 필요할까?

##### 값이 저장되는 일반적인 속성(변수)을 저장 속성이라고 함

- 그동안 우리가 배운 속성은 정확한 의미에서 "저장 속성"이었음: ====> 앞으로 저장 속성이 아닌 것을 배우게 됨

##### "계산속성이 아닌 방식"으로 구현 예시

- 비만도를 측정하는 체질량 지수(BMI)를 예시

```

class Person {

    var name: String = "사람"

    var height: Double = 160.0

    var weight: Double = 60.0

    func calculateBMI() -> Double {

        let bmi = weight / (height * height) * 10000

        return bmi
    }
}

let p = Person()

p.height = 165     // 키 165

p.weight = 65      // 몸무게 65

p.calculateBMI()   // 23.875

```

- calculateBMI()

- BMI를 계산하는 이 계산식은 파라미터가 없고,

- 내부에 가지고 있는 저장 속성값을 이용해, 계산한 후 결과값을 리턴한다.

### 위의 사례를 계산속성(Computed Properties)으로 바꾸어서 구현하기

> #### _밖에서 해당 인스턴스에 접근해서 "get" ➞ 값을 얻는다는 의미_

```
class Person1 {

    var name: String = "사람"

    var height: Double = 160.0

    var weight: Double = 60.0

    var bmi: Double {

        get {

            //get ===> 값을 얻는다는 의미

            let result = weight / (height * height) * 10000

            return result

        }
    }
}

let p1 = Person1()

p1.height = 165   // 키 165

p1.weight = 65    // 몸무게 65


p1.bmi


```

- 항상 다른 저장 속성에 의한 결과로 계산해 나오는 그런 방식의 메서드인 경우

- 아예 속성처럼 만들 수 있다. (===> 계산 속성)

- 다른 속성의 계산의 결과로 나오는 속성

- 하나의 문제: p1.bmi = 24 // get-only property (값을 세팅하는 것이 안되는 - 읽기 전용 계산 속성)

### 위의 사례를 읽기/쓰기가 가능한 계산속성으로 변경하기

> #### _밖에서 해당 인스턴스에 접근해서 "set" ➞ 값을 세팅(설정)한다는 의미_

```
class Person2 {

    var name: String = "사람"

    var height: Double = 160.0

    var weight: Double = 60.0

    var bmi: Double {

        get {        //getter ===> 값을 얻는다는 의미

            let bmi = weight / (height * height) * 10000

            return bmi

        }

        set(bmi) {   //setter ===> 값을 세팅한다(넣는다)는 의미

            weight = bmi * height * height / 10000
        }
    }

    /*

     만약에 쓰기 계산속성(set)을 메서드로 구현했다면

     func setWeightWithBMI(bmi: Double) {

     weight = bmi * height * height / 10000

     }

     */
}

let p2 = Person2()

p2.height = 165   // 키 165

p2.weight = 65    // 몸무게 65


p2.bmi

p2.bmi = 25

p2.weight


// 메서드로 구현 부분 확인하기


// p2.setWeightWithBMI(bmi: 24)

// p2.weight

```

### 읽기만 가능한 계산속성(read-only)은 get블록을 생략 가능

- 읽기만 가능한 계산 속성으로 구현한다면 get 블록을 생략하고, 구현할 수 있음

```

class Person3 {

    var name: String = "사람"

    var height: Double = 160.0

    var weight: Double = 60.0

    var bmi: Double {

        get {

            let bmi = weight / (height * height) * 10000

            return bmi
        }
    }
}

```

- get블록만 있다면, 굳이 한번 더 감쌀 필요가 없다. ===> 편의를 위해 get을 생략가능

### set블록의 파라미터를 생략하고 'newValue'로 대체가능

```

class Person4 {

    var name: String = "사람"

    var height: Double = 160.0

    var weight: Double = 60.0

    var bmi: Double {

        get {

            let bmi = weight / (height * height) * 10000

            return bmi

        }

        set {
            weight = newValue * height * height / 10000
        }
    }
}

```

### 계산 속성(Computed Properties) 이해하기

- 메서드가 아닌, 속성방식으로 구현하면 무슨 장점이 있을까?

- 관련이 있는 두가지 메서드(함수)를 한번에 구현할 수 있다.

- 그리고 외부에서 보기에 속성이름으로 설정가능하므로 보다 명확해 보임

- 따라서, 계산 속성은 메서드를 개발자들이 보다 읽기 쉽고, 명확하게 쓸 수 있는 형태인 속성으로 변환해 놓은 것이다.

- 실제로, 계산 속성은 겉모습은 속성(변수)형태를 가진 메서드(함수)임 ⭐️

- 계산 속성은 실제 메모리 공간을 가지지 않고, 해당 속성에 접근했을때 다른 속성에 접근해서 계산한후, 그 계산 결과를 리턴하거나 세팅하는 메서드 이다.

### 주의점

- 계산 속성 ===> 구조체, 클래스, (열거형) 동일

1.  항상 변하는 값이므로, var로 선언해야함 (let로 선언불가)

2.  자료형 선언을 해야함(형식추론 형태 안됨. 메서드이기 때문에 파라미터, 리턴형이 필요한 개념)

3.  get은 반드시 선언 해야함(값을 얻는 것은 필수, 값을 set하는 것은 선택)
